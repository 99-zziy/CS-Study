# JWT (JSON Web Token)

## 1. JWT란?

> Json Web Token의 약자입니다.
> JSON 객체를 사용하여 가볍고 자가수용적인 (self-contained) 방식으로 정보를 안전성 있게 전달해주기 위한 토큰입니다.

## 2. JWT의 구조

<br/>
<img width="591" alt="스크린샷 2021-09-28 오후 9 51 02" src="https://user-images.githubusercontent.com/62633444/135090266-423e8cfa-5e3a-4f8c-b93b-637b0b8b404a.png">
<br/>

- JWT는 ```.``` 을 구분자로 3가지 파트로 구성되어있습니다.
- 헤더(header), 내용(payload), 서명(signature)로 구성됩니다.


<br/><br/>
<img width="488" alt="스크린샷 2021-09-28 오후 9 53 32" src="https://user-images.githubusercontent.com/62633444/135090634-6b5e37b5-d4e5-4cb3-ad43-17c0c00703ea.png">
<br/><br/>

### 헤더(header)
헤더는 typ와 alg 두가지의 정보를 지니고 있습니다. 
typ는 토큰의 타입을 지정하고, JWT이기에 "JWT"라는 값이 들어갑니다. 
alg는 해싱 알고리즘을 지정하고, 기본적으로 HMAC, SHA256, RSA가 사용되면 토근을 검증 할 때 사용되는 signature부분에서 사용됩니다.

### 내용(payload)
Payload 부분에는 토큰을 담을 정보가 들어있습니다.   
정보의 한 조각을 클레임(claim)이라고 부르고, 이는 name / value의 한 쌍으로 이뤄져있습니다. 
여러 클레임을 넣을 수 있고, 클레임 에는 등록된(registered) 클레임, 공개(public) 클레임, 비공개 (private) 클레임으로 3가지 종류가 있습니다.

### 서명(signature) 
누구나 디코딩을 한다면 헤더와 페이로드의 내용을 볼 수 있습니다. -> 헤더와 페이로드는 단순히 JSON 문자열을 base64로 인코딩한 것이기때문에
누군가 JWT를 탈취하여 수정한 후 서버로 보낼 수 있습니다. 이 경우에 대비해 다른 사람이 위변조 했는지 검증하기 위한 부분입니다.  
이 서명은 header의 인코딩값과, payload의 인코딩값을 합친후 주어진 secretKey로 해쉬를 하여 생성합니다.  


## 3. 인증 과정

### 인증가 무엇인가? 그러면 인가는??

**인증**  
식별가능한 정보로 서비스에 등록된 사용자의 신원을 입증하는 절차  
ex) 로그인  
 
**인가**  
사용자가 요청하는 요청을 실행할 수 있는 권한 여부를 확인하는 절차  
ex) 로그인한 사용자가 글을 쓸 수 있는지, 글을 수정 할 수 있는 권한이 있는지 등등  
 

<img width="683" alt="스크린샷 2021-09-28 오후 10 20 27" src="https://user-images.githubusercontent.com/62633444/135094844-5a7447d0-56f8-43f4-9a3b-64b402d901ef.png">
사용자가 ID, PW를 입력하면 서버로 전송이 됩니다. 서버에서는 ID, PW를 DB에 조회하고 회원이면 로그인처리합니다.

<img width="683" alt="스크린샷 2021-09-28 오후 10 21 24" src="https://user-images.githubusercontent.com/62633444/135095000-d7da891a-f707-407f-a619-4e8861debb5d.png">
그런데 문제가 있습니다.   

HTTP는 Stateless(HTTP는 이전의 정보나 현재 통신의 상태가 남아 있지 않음)   

즉 사용자가 새로운 요청을 한다면 과거에 로그인한 사실을 기억하지 못합니다. 

**문제점 ) 사용자가 매번 로그인을 해야함**


<br/>


## Browser 활용하기 (쿠키 or 로컬스토리지 or 세션스토리지)
매번 로그인(인증)을 해야하는거를 안하기 위해서 (쿠키 or 로컬스토리지 or 세션스토리지)에 id, password를 넣어서 요청을 보낼때 계속 보냄

**문제점) raw한 데이터가 쿠키에 저장되어있어 해커에게 그대로 노출될 수 있음, 클라이언트는 서버보다 상대적으로 보안이 취약함 결국, 보안에 좋지 않음**

<br/>

## 서버 기반 인증

<img width="775" alt="스크린샷 2021-09-28 오후 10 30 07" src="https://user-images.githubusercontent.com/62633444/135096423-3cf7939e-98fa-4492-8e29-94a3ad271cba.png">

서버 기반 인증 방식의 핵심은 서버측에서 유저 정보를 저장하는 것입니다.  
대표적으로 세션을 사용하는 방법이 이에 해당합니다. 유저가 로그인을 하면 서버는 해당 유저의 세션을 만들고 서버의 메모리와 데이터 베이스에 저장합니다.  
세션 데이터가 서버의 메모리에 저장됩니다. 사용자가 증가하여 서버를 확장하면 모든 서버에게 세션의 정보를 공유해야합니다. 따라서 별도의 중앙 세션 관리 서버를 만들게 됩니다.  

**문제점) 큰서비스가 된다면 로드밸랜서 사용하게 되는데 두번째 요청에서 세션id를 저장한 서버가 아닌 다른 서버를 이용하게 된다면 문제가 발생된다.  
-> 이문제는 서버 하나 하나가 세션을 관리하기 때문에 만들어진 문제인데, 이 문제는 따로 세션 디비를 두어 해결할 수 있다.   
그러나 한 곳에서 모든 세션을 관리하기 때문에 클라이언트가 많을 때는 과부하가 걸릴수 있다.**

---
> **이러한 문제는 왜 계속 생기는가?**  
> http의 특성은 무상태성인데, 인증과 인가의 과정은 상태성을 가지고 있다. 
 이 두가지의 충돌때문이다.
---

 <br/>
 

JWT를 이용한 인증과정을 알아보기전에 Access Token / Refresh Token에 대해 알아봅시다.

**액세스 토큰(Access Token)**
- 리소스에 직접 접근할 수 있도록 해주는 정보만을 갖고 있습니다.
- Refresh Token에 비해서 짧은 만료 기간을 갖습니다.
- 주로 세션에 담아서 관리한다.

**리프래시 토큰(Refresh Token)**
- 새로운 Access Token을 발급받기 위한 정보를 갖습니다.
- 클라이언트가 Access Token이 없거나 만료되면 Refresh Token을 통해 Auth Server에 요청해서 새로운 Access Token을 발급 받을 수 있습니다.
- Access Token에 비해서 긴 만료 기간을 갖습니다.
- 외부에 노출되지 않도록 관리를 위해서 데이터베이스에 저장한다.


**왜 access Token과 refresh Token이 Token이 왜 2개일까?  
access token이 탈취되면 해커도 사용자와 똑같은 권한을 갖게되므로 또 보안상의 문제가 발생하게 된다.   
그래서 이를 위해 만료기간을 정함, 그러나 만료기간이 끝나면 해커도 사용을 못하지만 사용자도 사용하지 못한다. 그래서 나온것이 refrsh token 이다.**

<br/>

## JWT 기반 인증


<img width="769" alt="스크린샷 2021-09-28 오후 10 10 06" src="https://user-images.githubusercontent.com/62633444/135093281-73a2b90f-2c00-4f4a-b3f4-5165ed3d2f32.png">

1. 로그인
2. secret키를 통해 access token, refresh token을 생성, 디비에는 refresh token만 저장함, 클라이언트에 보낼때는 access token, refresh token을 보냄
3. 클라이언트는 클라이언트가 Authorization header에 Access Token을 담아서 보냄
4. access token에 문제가 없으면 응답해줌
5. access token이 만료되었으면 refresh token을 통해 새로 access token를 생성함


그러나 토큰도 탈취당할 수 있기때문에 관리를 해야한다.!!

## 4. JWT의 장점 & 단점

**장점**
- 훌륭한 확장성
  (서버 기반 인증에서 보았듯이 세션을 이용한다면 스케일 아웃(서버 확장) 할 때마다 각 서버마다 세션 정보를 저장하게 됩니다. 사용자1이 [서버 1]에서 로그인 인증을 받았습니다. 그동안 사용자가 증가하여 [서버 2]로 스케일 아웃이 일어났습니다. 그러나 [서버2]는 사용자1이 로그인 했는지를 알지 못합니다.
서버가 늘어나도 토큰을 인증하는 방식만 알고 있다면 사용자 인증에 문제가 없습니다.)


**단점**
- 데이터 증가에 따른 네트워크 부하 증가
(모든 요청에 대해서 토큰이 전송되므로 토큰에 담기는 정보가 증가할 수록 네트워크 부하가 증가합니다. 그래서 보통 약자가 많이 사용됩니다.)
- Stateless
(JWT는 상태를 저장하지 않기 때문에 한번 만들어지면 제어가 불가능합니다. 토큰을 임의로 삭제하는 것이 불가능하므로 만료 시간을 꼭 넣어 주어야 합니다.)


